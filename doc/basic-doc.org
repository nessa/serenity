* Definicion del proyecto
** Descripción
Proyecto Serenity (Recetario de cocina para Android)
** Elementos
- API
- App Android
- Web (futuro)

** Objetivos
*** Primarios
- Semántica:
  + Ingredientes "restringidos" y medidas "estándares"
  + Introducción de pasos delimitada
- Cronómetro (opcional) en cada paso
- Media (opcional) en cada paso: imagen o video
- Valorar recetas (puntuación)

*** Secundarios o futuros
- Dashboard inicial (recomendación de recetas en función de los
  gustos)
- Lectura automática de la receta
- Reconocimiento de voz (órdenes de lectura)

** API
*** Clases
- Recipe:
  + Title
  + User
  + Language
  + Created timestamp
  + Updated timestamp
  + Cooking time
  + Image URL (¿?)
  + Total rating
  + Users rating
  + Servings
  + Source (URL or text)
  + Categories (array):
    * Category
  + Ingredients (array):
    * Quantity
    * Name
    * Measurement unit
  + Directions (array):
    * Sort number
    * Description
    * Image URL (¿?)
    * Video URL (¿?)
    * Time
  + Comments (array):
    * User
    * Comment

**** Future
- Menu (recipes set)
- Rating (user - recipes)

** Cuestiones
*** Qué base de datos escoger
- ¿SQL o NoSQL?
- Cuál de ellas
*** Qué framework para la API escoger
- Lenguaje: Python
  Ya he trabajado con APIs en PHP y de los demás lenguajes, me
  interesa probar con Python por ver otra faceta más de éste.

- Qué framework: ¿Django o Flask?
  Django es más complejo, pero permite hacer más cosas.

*** Qué plataforma para la App escoger
- iOS: trabajo con ella habitualmente, por lo que no me
  interesa. Además es muy caro y no puedo permitírmelo: 90$ al año +
  Mac.
- Firefox OS: no tiene mucho mercado todavía. Quizá en un futuro.
- Windows Phone: hay que desarrollar desde Windows 8 y, por
  principios, no utilizo ese sistema, sólo uso equipos con GNU Linux
  (salvo en el trabajo que uso Mac).
- Android: elegido por poseer un mercado enorme, poseer un equipo
  apto para su desarrollo y económicamente es mucho más viable
  desarrollar (20 $ para toda la vida). Además tengo dispositivos
  Android en los que poder realizar pruebas físicas, además de en el
  simulador.
  + Motivación por dicha tecnología: Estoy trabajando desarrollando
    aplicaciones para iOS y quiero aprender otras tecnologías. Además
    prefiero que sean software libre, tanto por afinidad como por
    economía (dado que además de libre es gratuito el desarrollo y la
    publicación).

*** Monetización
- Añadir publicidad
- Donaciones voluntarias, pero eso no cuenta.
- ¿Algo más?
* Primera fase: API
** Instalación desde cero
- Python: sudo apt-get install python-dev build-essential python3-dev
- PIP: sudo apt-get install python-pip
- Virtualenv: sudo pip install virtualenv
- PostgreSQL:
  + sudo apt-get install postgresql postgresql-contrib libpq-dev
  + GUI: sudo apt-get install pgadmin3
  + Change password: sudo -u postgres psql postgres
  + \password postgres
  + Create DB: sudo -u postgres createdb amusedb
  + Lanzar servidor: sudo service postgresql start
- Redis:
  + wget http://download.redis.io/releases/redis-2.8.12.tar.gz
  + tar xzf redis-2.8.12.tar.gz
  + cd redis-2.8.12
  + make
- Sphinx: sudo apt-get install python-sphinx

** Virtualenv
- Activar virtualenv:
  + La versión de python es opcional (toma una por defecto):
    virtualenv -p /usr/bin/python3 env 
  + source env/bin/activate
  + Nota: Para salir del entorno de virtualenv, usar deactivate
- Instalar paquetes requeridos:
  + pip install django
- django-admin.py startproject
  --template=https://github.com/sebastibe/django-rest-skeleton/archive/master.zip amuseapi
- Flake8: pip install flake8
  + Para usarlo: flake8 directorio
  + Intentar instalar el hook para git (no ha funcionado la primera vez)

** Configuración básica de Django
- Actualizar paquetes requeridos:
  pip install -r reqs/all.txt
- Crear un nuevo proyecto de Django:
  + django-admin.py startproject nombre-proyecto
  + cd nombre-proyecto
- Crear una nueva app:
  + python manage.py startapp nombre-app
- Configurar la base de datos en nombre-proyecto/settings.py
  + python ./manage.py syncdb
  + python ./manage.py createsuperuser
- Configurar las URLs en nombre-proyecto/urls.py

** Configuración nueva plantilla
- Desarrollo o producción: echo "true" > envdir/DEBUG
- Base de datos estilo Heroku:
   echo "postgres://postgres@localhost:5432/project" > envdir/DATABASE_URL
- Configuración de Postgres:
  + Añadir -d para desarrollo: sudo -u postgres createuser -d -A -P amuseuser
  + sudo -u postgres createdb -O amuseuser amusedb
- Ejecutar Redis Server: $DIR/src/redis-server
- Ejecutar configuración de Sphinx: sphinx-quickstart
- Django Model Utils: pip install django-model-utils
- Settings.py:
  + Línea 272: Actualizar usuario, contraseña y BD

** Objetivos
- Recetas:
  + Datos básicos
  + Categorías
  + Ingredientes
  + Direcciones
  + (Comentarios)
- Método listar recetas
- Método listar usuarios
- Login y autenticación
- Método crear recetas
- Método actualizar recetas
* Segunda fase: App

* Diario
** Previo
*** [API] 11 septiembre
- Ejecución del servidor: python ./manage.py runserver
- Da un error por no tener instalado ciertas cosas, así que intento
  reinstalar todos los paquetes requeridos:
  pip install -r reqs/all.txt
- Error: No moduel named 'backends'
- pip install --upgrade setuptools
- El módulo oAuth2 no soporta python 3
- Desinstalar oauth2: pip uninstall django-oauth2-provider
- Borrar los dos entornos de virtualenv y empezar con uno nuevo en el
  directorio amuseapi
- Crear un nuevo entorno e instalar los paquetes de reqs/required.txt
  y reqs/optional.txt (reqs/all.txt)
- Comentar las líneas 154 a 164 de api/settings.py
- Ya ejecuta correctamente el servidor.
- Siguiente día: probar usuario administrador e intentar hacer un modelo.

*** [API] 12 septiembre
- El ordenador ha vuelto a fallar, así que instalo todo de cero en el ordenador del trabajo.
- Instalar python3 y buscar directorio
- Instalar pip y virtualenv
- Generar un nuevo entorno y entrar: virtualenv -p /usr/local/bin/python3 env
- Instalar postgres (antes de instalar los paquetes o psycopg2 fallará):
  + brew install postgresql
  + sudo gem install lunchy
  + sudo mkdir -p ~/Library/LaunchAgents
  + sudo cp /usr/local/Cellar/postgresql/9.3.4/homebrew.mxcl.postgresql.plist ~/Library/LaunchAgents/
  + Fuente: http://www.moncefbelyamani.com/how-to-install-postgresql-on-a-mac-with-homebrew-and-lunchy/
- Iniciar postgres: lunchy start postgres
- Instalar paquetes requeridos: pip install -r reqs/all.txt
- Crear archivos de envdir:
  + echo "postgres://postgres@localhost:5432/project" > DATABASE_URL
  + echo "true" > DEBUG (o false)
  + echo "password" > SECRET_KEY

*** [API] 1 diciembre
**** Vagrant
    - Nuevo repo: drf-vagrant-config
    - Uso:
      + vagrant up
      + vagrant ssh
      + vagrant destroy
    - Fracaso total: no funciona nada. Problemas con ansible.
    - Borrado del repo
**** Reinicio
    - source env/bin/activate
    - pip install -r reqs/all.txt
    - python manage.py runserver
    - Funciona, pero da un error de permisos: "Authentication
      credentials were not provided."
**** Postgre
    - Acceso:  sudo -u postgres psql
    - El usuario, la base de datos y la contraseña están
      correctamente definidos.
    - Reconfiguración de la base de datos en settings.py:
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'amusedb',
        'USER': 'amuseuser',
        'PASSWORD': '171287',
        'HOST': '127.0.0.1'
    }
}

**** Otros problemas
    - Nuevo error: "relation "django_site" does not exist"
    - Resincronizando DB: python manage.py syncdb
      A partir de ahora hay que usar manage.py migrate, para no
      perder los datos.
    - Fallo de sincronización con users_User: ./manage.py migrate
    - Creación de superusuario: ./manage.py createsuperuser
    - Entrar en la URL y loguearse ya funciona.

** Enero
*** [API] 7 enero
- Buscando tipos de datos
- Maps y lists: http://drf-compound-fields.readthedocs.org/en/latest/readme.html

*** [API] 10 enero
- Nuevos modelos de datos
- Nuevos serializadores
- Nuevas vistas
- Al probar la vista "recipe_list" da un error. No se si tiene que
  ver con que no exista ninguna receta en la base de datos.
*** [API] 11 enero
- ./manage.py syncdb
  Creando tablas:
Creating table recipes_category
Creating table recipes_ingredient
Creating table recipes_direction
Creating table recipes_comment
Creating table recipes_recipe_ingredients
Creating table recipes_recipe_comments
Creating table recipes_recipe_directions
Creating table recipes_recipe_categories
Creating table recipes_recipe
   Elementos no sincronizados:
Not synced (use migrations):
 - rest_framework.authtoken
 - api.users
 - django_extensions
(use ./manage.py migrate to migrate these)

- Probablemente debería haber usado: python manage.py makemigrations
  recipes
  + No. makemigrations ya no existe.
- Añadiendo permisos a la API:
  +  Abrir los GETs a cualquiera (aunque no esté logueado).
- Añadiendo usuario a la receta.
- Añadiendo hipervínculos a toda la API.
- Fallo con users.
  + Tratando de hacer una migración, no funciona.
  + Prueba de actualización de django a versión 1.7.2: no es
    compatible con south (hay que hacer una actualización distinta).
    https://docs.djangoproject.com/en/dev/topics/migrations/#upgrading-from-south
  + Restauración de django (versión 1.6.9 en lugar de 1.6.5).
  + Borrado de la base de datos (desde línea de comandos como usuario postgres):
    dropdb 'amusedb'
  + Creándola de nuevo:
    createdb -O amuseuser amusedb
  + Sincronizando esquema:
    ./manage.py syncdb
    ./manage.py migrate
  + Creando superusuario de nuevo:
    ./manage.py createsuperuser
  + Ahora sí funciona users.

*** [API] 12 enero
- Añadiendo nuevos serializers (para los demás elementos).
- Definiendo timestamps por defecto (actualizables en create o en
  update).
- Intentando buscar una forma de añadir un nuevo método: rate, para
  añadir puntuación sin ser usuario poseedor de la receta y modificar
  2 variables del modelo (total_rating y users_rating) a partir de
  ambas y una tercera dada (la puntuación del nuevo usuario).
- También hay que añadir filtros (normales y de campos manytomany).
  http://stackoverflow.com/questions/25943426/django-rest-framework-get-filter-on-manytomany-field

*** [API] 13 enero
- Definiendo método de puntuación básico: recipe el id de la receta y
  la puntuación e incrementa la puntuación total en el valor dado y
  el número de usuarios que han votado en 1.
  + Habría que incluir una tabla más al modelo, con las puntuaciones,
    para que cada usuario sepa que ya ha votado y cuál ha sido su
    puntuación.
  + También habría que añadir esa tabla a una comprobación inicial en
    el método de puntuación, para que si hay una puntuación ya dada
    se modifique (para ello, habría que dar otro dato más, que sería
    la puntuación anterior, o mejor se podría obtener de la tabla
    anexa).
- Añadiendo filtros básicos a Recipe.
- Añadiendo filtros complejos: categories, ingredients, users.
- Hay que probar si la inserción de datos, modificación y lectura
  funciona correctamente.

*** [API] 14 enero
- Abriendo los métodos GET a cualquier usuario (registrado o anónimo).
- Users no funciona de ninguna manera.
- Migración de datos:
  + ./manage.py schemamigration users --initial (no hace falta)
  + ./manage.py schemamigration recipes --initial
  + Borrar y crear base de datos
  + ./manage.py syncdb
  + ./manage.py migrate authtoken (hace la de users también)
  + ./manage.py migrate recipes
  + ./manage.py migrate django_extensions
  + ./manage.py createsuperuser
- El usuario no se está enlazando porque no existe (hay un
  superusuario que no tiene nada que ver con uno de clase User)
*** [API] 15 enero
- Sigo teniendo el mismo problema con los usuarios. He mirado en la
  base de datos de postgre, pero no veo nada.
- El error es:
  IntegrityError: null value in column "owner_id" violates not-null
  constraint

*** [API] 17 enero
- Revisión de errores comunes con el usuario. Es un problema de las
  funciones usadas (son para versiones más actuales de las que venía
  usando).
  + Solución: actualizar django-rest-framework de la versión 2.3.14 a
    la 3.0.3.
- Revisión de errores leves de imágenes y videos (no se permite que
  sean campos con cadenas vacías).
  + Solución: añadir al serializador el campo 'allow_blank' a True.
- Nuevo error: los campos anidados no se generan automáticamente. Hay
  que sobreescribir los métodos de creación para cada uno de ellos
  tal y como explica este enlace:
  http://stackoverflow.com/questions/14978464/django-rest-nested-object-add-on-create-post-not-just-update-put
- Nota: No dejar nunca otros ficheros en el directorio de migraciones.
- Cambiando la estructura de los modelos:
  + Nuevo campo 'recipe' que enlaza desde categorías, ingredientes,
    etc al objecto 'Recipe'.
  + Ahora estas listas se utilizan como el campo 'recipes' de usuario
    (realmente no existe, sino que se lee en el momento a partir de
    los datos de las demás tablas).
- ¡Funciona! ¡Ya se pueden crear recetas!
*** [API] 18 enero
- Implementación del método update. Sólo actualiza si es
  necesario.
- Empezando a leer acerca de Android y Material:
  + http://developer.android.com/training/material/index.html
  + http://developer.android.com/training/material/get-started.html
- Review de la especificación de Material. Actualmente voy por:
  http://www.google.com/design/spec/animation/authentic-motion.html
*** [API] 19 enero
- Instalando Postgre en Mac OS X:
  + http://www.enterprisedb.com/products-services-training/pgdownload#osx
  + sudo su postgres
  + psql
  + Crear usuario: CREATE USER amuseuser WITH PASSWORD 'X';
  + Crear base de datos: createdb -O user name
  + Sincronización y migración de datos (syncdb, etc)
  + Ejecución: funciona correctamente
- Definiendo un orden por defecto en ingredientes y direcciones (en función
  de sort_order).
- Comprobando que el método delete borra tanto la propia receta como los
  campos anidados correspondientes (usando psql).
- Arreglando un error de redundancia en el serializador de usuario
  (aparecía denifido el 'source' de los campos first_name y
  second_name y no es necesario puesto que se llaman igual).
- He encontrado el layout que me gustaría usar para la vista
  principal. Parecido al que aparece en la sección Animation >
  Meaningful transitions > Visual continuity
  http://www.google.com/design/spec/animation/meaningful-transitions.html#meaningful-transitions-visual-continuity
- Las transiciones necesarias se pueden ver aquí:
  http://developer.android.com/training/material/animations.html#Transitions
- Sigo leyendo la especificación de Material. Voy por:
  http://www.google.com/design/spec/patterns/data-formats.html
*** [APP] 20 enero
- Getting started: http://developer.android.com/training/basics/firstapp/index.html
- Primera app.
- Eligiendo colores de la app e idea para el icono (amuse bouche de pepino):
  + DARK PRIMARY COLOR: #689F38
  + PRIMARY COLOR: #8BC34A
  + LIGHT PRIMARY COLOR: #DCEDC8
  + TEXT / ICONS: #212121
  + ACCENT COLOR: #FF5722
  + PRIMARY TEXT: #212121
  + SECONDARY TEXT: #727272
  + DIVIDER COLOR: #B6B6B6
- Construyendo la interfaz: http://developer.android.com/training/basics/firstapp/building-ui.html
*** [APP] 21 enero
- Ejecución en dispositivo físico:
  + Activar las opciones de desarrollo. Para ello, en el móvil acceder a
    Ajustes > Acerca del teléfono y pulsar 7 veces "Número de compilación".
  + Habilitar depuración USB. Para ello acceder a Ajustes > Opciones de
    desarrollo y activar "Depuración USB".
- Añadir definición de colores: fichero res/values/colors.xml
- Añadir iconos en directorios: res/drawable/ldpi (o mdpi, xdpi, xxdpi, xxxdpi)
- Siguiente sección:
  http://developer.android.com/training/basics/activity-lifecycle/starting.html
*** [APP] 22 enero
- Desarrollando el grid en la ventana principal.
- Añadiendo icono de "búsqueda" a la barra de título.
- Añadiendo colores al estilo.
*** [APP] 25 enero
- Añadiendo nueva vista de detalle (sin layout específico).
- Haciendo pruebas de transiciones. Hay dos formas de hacer la
  transición que queremos:
  + A través del gridview, para lo cual hace falta especificar el
    siguiente parámetro en el RelativeLayout de la celda:
    android:descendantFocusability="blocksDescendants"
    El problema de este caso es que no interviene la propia imagen,
    sino la celda completa, por lo que la transición no queda todo lo
    bien que podría.
  + A través de la imagen insertada en el ImageAdapter. La dificultad
    de este método está en que hay que tomar la actividad desde la
    que queremos transitar del propio contexto.
- Cuando se añada una image principal al layout que corresponde,
  podremos probar si es adecuada la transición.
- Lo siguiente es añadir un botón flotante para crear nuevas recetas:
  +
    http://www.myandroidsolutions.com/2015/01/01/android-floating-action-button-fab-tutorial/
  +
    http://www.bignerdranch.com/blog/floating-action-buttons-in-android-l/
- He modificado parte del manifest, para añadir información.
- Después de mucho buscar, he añadido el botón que ha hecho este
  usuario, que me ha parecido la mejor opción:
  http://prolificinteractive.com/blog/2014/07/24/android-floating-action-button-aka-fab/
- Buscando una alternativa parecida a esta para mover elementos en
  función del scroll: https://github.com/lawloretienne/QuickReturn
- [API] Revisando la subida de archivos en DJango:
  + https://docs.djangoproject.com/en/1.7/topics/http/file-uploads/
  + http://stackoverflow.com/questions/5871730/need-a-minimal-django-file-upload-example
*** [APP] 26 enero
- Diseño de icono de la aplicación.
- Hay que añadir el menú lateral:
  + https://gpmess.com/blog/2014/04/08/implementar-un-menu-lateral-usando-navigationdrawer-en-android#.VMYnh2SG-G8
- Información acerca del reconocimiento de voz:
  + http://www.jameselsey.co.uk/blogs/techblog/android-how-to-implement-voice-recognition-a-nice-easy-tutorial/
  + http://androidbite.blogspot.com.es/2013/04/android-voice-recognition-example.html
  + http://code4reference.com/2012/07/tutorial-android-voice-recognition/
  + http://stackoverflow.com/questions/11789791/android-speech-to-text-example
  + http://viralpatel.net/blogs/android-speech-to-text-api/
*** [APP] 27 enero
- Pasando de usar activities a usar una única activity y varios fragments.
- Añadiendo un menu lateral (casi todo el tiempo he estado con esto, porque
  daba muchos problemas a la hora de integrarlo con fragments).
- Corrigiendo problema con el botón que lanza el menú lateral (quería que cuando
  pasara a otro fragment saliera el botón de volver hacia atrás).
- Diferenciando los menús de cada fragment (de momento sólo list y detail).
- Limpiando y comentando el código.
- Falta colocar de nuevo el FAB para tener la aplicación como estaba antes de
  los cambios de hoy.
*** [APP] 28 enero
- Añadiendo el FAB correctamente. He tenido que reescribirlo entero.
- Información acerca de JSON y obtener datos de una API:
  + http://www.androidhive.info/2012/01/android-json-parsing-tutorial/
- Información acerca de speech:
  + http://developer.android.com/reference/android/speech/tts/package-summary.html
  + http://developer.android.com/reference/android/speech/package-summary.html
- Prueba de text-to-speech exitosa.
*** 29 enero
- Ideas para el proyecto:
  + Implementar modelos ocultos de Markov en Django para que al hacer
    un GET de una receta concreta se devuelva también las recetas que
    "también te pueden gustar" (en función del conjunto de recetas que
    otros usuarios han seteado como favoritas).
    * Tengo que pensar cómo encajarían estas recetas en el modelo de
      fragments actual. ¿Probablemente deba añadir otra actividad? De
      todas formas, puede que me hiciera falta igualmente, puesto que
      hay otros fragments que añadir (creo): cronómetro, imagen a
      pantalla completa, video idem,...
    *
      http://www.genbetadev.com/paradigmas-de-programacion/seleccion-aleatoria-ponderada-y-las-cadenas-de-markov
    * http://scikit-learn.org/stable/modules/hmm.html
    * https://github.com/jamesmcinerney/np-hmm
    * https://bitbucket.org/GuyZ/hmm
  + Para añadir la conexión con dbpedia:
    * Hay que añadir un modelo "Ingrediente", que contenga el idioma
      del ingrediente, el nombre, la fecha de creación y modificación
      (para hacer los sincronizadores más eficientes) y la URL del
      elemento de dbpedia que le corresponda.
    * Además esta URL (es decir, la adición de un nuevo Ingrediente
      genérico) se deberá hacer a la hora de subir nuevas recetas y
      comprobar que hay un ingrediente que no existe.
    * Para facilitar el uso de la app a usuarios básicos, este
      comportamiento deberá activarse en la configuración de la
      aplicación. Así que, por defecto, un usuario podrá subir una
      receta con un ingrediente que defina él o ella, pero no tiene
      porqué estar registrado en la base de datos como ingrediente
      genérico.
    * Estos ingredientes genéricos se utilizarán también para que los
      campos de texto donde se deban añadir ingredientes se
      autocompleten (para facilitar la elección a los usuarios).
  + Sincronización:
    * En principio no va a haber una sincronización de recetas
      automática (es decir, una conexión inicial de la base de datos
      para bajarse todas las recetas).
    * Al iniciar la aplicación se comprobará si hay conexión internet
      o no. Si la hay, el gridview principal se actualizará con las
      10 recetas que corresponda (las 10 más votadas, por
      ejemplo). Si no la hay, se comprobará si hay recetas guardadas
      en la base de datos y se cargarán en el gridview en función de
      algún criterio (puede que el mismo). Si no hay ninguna de las
      dos, se informará al usuario de que no hay datos y debe
      conectarse a internet.
    * Cuando se entre en una receta (o aparezca en el gridview
      principal) y ésta se encuentre guardada en la base de datos, si
      hay conexión a internet, ésta deberá ser actualizada en la base
      de datos para que los datos sean lo más correctos posible.
  + Media:
    * Si una receta no tiene enlazada una imagen principal, deberá
      tomarse una de las imágenes creadas como "demo" para no
      prescindir de la transición del fragment (de imagen a imagen).
- TODO Prueba de voz: comprobar si TTS tiene pausas de tiempo y se
  puede ejecutar en secuencia, o se lanzan todas las órdenes a la
  vez. Si se ejecutan a la vez, buscar cómo averiguar cuando ha
  terminado.
*** 20 febrero
- Trabajando en los mockups de la aplicación (diseño completo).
** Abril
*** [API] 4 abril
- Pruebas de inicio.
- Añadiendo nuevas recetas (4 de momento). El objetivo es empezar a
  programar la descarga de recetas (necesito más de 10, si puede ser
  más de 20, para ver cómo se comporta la APP).
- Añadiendo litros y mililitros como medidas aceptadas.
  + time y quantity = 0 significa que no tienen valor definido (por
    lo que ni se mostrará).
** Junio
*** [API] 15 junio
- Para rellenar la base de datos con datos iniciales hay que utilizar
  fixtures: https://docs.djangoproject.com/en/1.8/howto/initial-data/
- El archivo debe seguir una sixtaxis concreta, por lo que es preferible
  rellenar la base de datos con toda la información que se desee y lueg
  ejecutar el siguiente comando para exportar toda la información:
  + ./manage.py dumpdata recipes > recipes/fixtures/initial_data.json
- Para cargar el fixture es necesario ejecutar:
  + ./manage.py loaddata recipes/fixtures/initial_data.json
*** [API]16 junio
- Intentando arreglar el método rate_recipe (sigue fallando).
- Info: http://www.django-rest-framework.org/api-guide/views/
- Categorización de platos:
  + Intolerancias:
    * SUITABLE-FOR-CELIACS
    * SUITABLE-FOR-LACTOSE-INTOLERANTS
  + Tipos de regímenes:
    * LOW-CALORIES (bajo en calorías)
    * LOW-FAT (bajo en grasa)
    * LOW-CARB (bajo en hidratos de carbono)
    * VEGETARIAN
    * VEGAN
  + Tipo de plato:
    * APPETIZER (aperitivo)
    * FIRST COURSE (primer plato)
    * SECOND COURSE (segundo plato)
    * MAIN DISH (plato principal)
    * DESSERT (postre)
    * OTHER
  + Dificultad:
    * HIGH
    * MEDIUM
    * LOW
  + Idioma
  + País o zona típica de esta receta

*** [API] 16 junio
- He añadido 2 campos nuevos al modelo de recetas: type_of_dish y difficulty
- He creado un nuevo archivo de migración para añadir esos 2 nuevos campos

*** [API] 17 junio
- He terminado de añadir 21 recetas a la base de datos.
- He exportado los datos de usuarios y recetas a los archivos del directorio
  fixtures.
- Para restaurar los datos:
  + ./manage.py loaddata recipes/fixtures/users_initial_data.json
  + ./manage.py loaddata recipes/fixtures/recipes_initial_data.json

*** [API-APP] 19 junio
- He empezado a desarrollar la descarga de objetos JSON de la API.
- El servidor no es público, por lo que no puedo probar las cosas desde el
  móvil. Y el emulador va demasiado lento.
- Opto por intentar utilizar vagrant y ansible para ejecutar un servidor
  que pueda funcionar correctamente.
- Reestructuro el repositorio (hay un nivel de directorio que no tiene sentido
  y dificulta la configuración de ansible).
- Actualización de la configuración de Vagrant y Ansible (fork de abrahanfer).
- Instalación de vagrant, ansible y virtualbox.
- Ejecutar vagrant up (o vagrant provision para seguir desde un punto con la
  máquina arrancada).
- Pruebas varias con vagrant.
- He actualizado todo el proyecto a la última versión de Django y me he desecho
  de muchos paquetes que no eran necesarios. Las primeras pruebas indican que
  sigue funcionando, pero hay que comprobarlo más a fondo.

*** [API] 22 junio
- Actualizando la configuración de Vagrant para poder hacer llamadas a la API
  desde otros dispositivos (forwarded ports). Acceder a través de
  http://IP-pública:8002
- Creando un usuario personalizado con campos nuevos.
- Migrando datos y creando un dump de datos para cargarlo al inicio.
- Si falla el git clone, probablemente es porque hay que hacer un pull en local
  para meter la contraseña por primera vez.

*** [APP] 23 junio
- Sincronización con la API (get Recipes)

*** [APP] 25 junio
- Comprobación de conexión a internet.
- Obtener imágenes aleatorias para colocar en las recetas cuando la que venga
  esté vacía o no se encuentre.
- Añadiendo nueva clase Recipe, que implementa Parcelable (para poder pasar
  los datos a través de intents y bundles).

*** [APP] 26 junio
- Añadiendo nueva forma de descargar las imágenes:
  + Librería Picasso: http://square.github.io/picasso/
  + Está licenciada bajo Licencia Apache (compatible según la Free Software
    Foundation con GPLv3).
  + Resuelve el problema del grid (desorden en las vistas y mal funcionamiento
    de memoria). Utilizar un método que implemente AsyncTask en este caso no es
    suficiente, porque hay que manejar la cache y tener en cuenta muchos otros
    factores.
- He añadido una nueva Activity para la vista de detalle. También he ampliado
  el layout del fragment correspondiente y he corregido la transición (que no 
  funcionaba). También se pasa la receta a través de un Bundle.

** Octubre
*** 11 octubre
- Instalación y configuración del proyecto Android en el nuevo
  sobremesa.
- Ejecución correcta.

** Marzo 2016
*** 13
- Arreglando captura de órdenes en la app
*** 14
+ Implementación de ratings en API
+ Implementación de comentarios en API
+ Modificando permisos de las peticiones en la API

** Importante
*** Básico
- Migración de datos:
  + dropbd amusedb
  + createdb -O amuseuser amusedb
  + ./manage.py migrate
  + ./manage.py createsuperuser
- Fixture:
  + ./manage.py dumpdata recipes > recipes/fixtures/initial_data.json
  + ./manage.py loaddata recipes/fixtures/initial_data.json
- Vagrant:
  + up: ejecutar
  + provision: para seguir desde un punto con la máquina arrancada
  + halt: apagar la máquina
  + destroy: destruir la máquina (al iniciarla instalará todo desde 0)
  + Ejecución:
    * Cambiar variable domain en vars.yml (a la IP pública)
    * Parar apache (no se si es necesario)
    * Hacer pull en local de un proyecto (para que solicite la contraseña
      y no se bloquee después)
    * Vagrant up
    * Vagrant provision
- Postgre desde terminal:
  + Borrar base de datos: dropdb 'name'
  + Create base de datos: createdb -O user name
  + Acceder: psql (siendo usuario postgres)
- Postgre desde PSQL:
  + Lista DB: \l
  + Ayuda: \?
  + Conectar a una DB: \c database
  + Ver tablas: \dt
  + Queries: tipo SQL normales
- Iconos Material:
  + Referencia: https://google.github.io/material-design-icons/
  + Repo: https://github.com/google/material-design-icons
*** Instalaciones primarias
**** Virtualenv
- Python: sudo apt-get install python-dev build-essential python3-dev
- PIP: sudo apt-get install python-pip
- Virtualenv: sudo pip install virtualenv
- PostgreSQL:
  + sudo apt-get install postgresql postgresql-contrib libpq-dev
  + GUI: sudo apt-get install pgadmin3
  + Change password: sudo -u postgres psql postgres
  + \password postgres
  + Añadir -d para desarrollo: sudo -u postgres createuser -d -A -P amuseuser
  + sudo -u postgres createdb -O amuseuser amusedb
  + Lanzar servidor: sudo service postgresql start
- Activar virtualenv:
  + La versión de python es opcional (toma una por defecto):
    virtualenv -p /usr/bin/python3 env 
  + source env/bin/activate
  + pip install -r reqs/all.txt
- Reiniciar datos
  + dropbd amusedb
  + createdb -O amuseuser amusedb
  + ./manage.py migrate
  + ./manage.py createsuperuser
**** Modificación de un modelo
- ./manage.py makemigrations
- ./manage.py migrate
**** Vagrant
- sudo apt-get install virtualbox
- sudo apt-get install vagrant
- sudo apt-get install virtualbox-dkms
- vagrant up



** Por hacer
- TODO: Método para agregar comentarios a una receta (independiente de
  los métodos básicos). Probablemente a través de su propio endpoint
  (comments).
- TODO: Añadir nuevos modelos Ingredient y Category (genéricos) que
  añadan cada nuevo ingrediente y categoría que no esté creado ya y
  pueda servir para filtrar recetas y obtener información secundaria.
  + Añadirlo solo para ingredientes (categorías serán fijas).
- TODO: Definición del layout inicial en Inkscape.
- TODO: Posibilidad. ¿Añadir un campo 'rating' para facilitar la
  filtración en función de un único campo en lugar de tener que usar
  2 (total_rating y users_rating)?
- TODO: Conexión con DBpedia:
  + http://es.dbpedia.org/index.html
  + http://es.dbpedia.org/sparql
  + Consultas: http://es.dbpedia.org/wiki/Wiki.jsp?page=Ejemplos%20de%20consultas%20SPARQL
  + http://es.dbpedia.org/page/Receta_de_cocina
  + http://es.dbpedia.org/page/Categor%C3%ADa:Gastronom%C3%ADa
- TODO: Guardar recipe draft en onPause() (si mientras se está creando 
  una receta se sale de la app)
- TODO: Sin conexión = recetas favoritas y recetas propias (creadas en la app)
- TODO: Conectar con Amazon S3 (web services)
  + http://aws.amazon.com/es/mobile/sdk/
  + http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/setup.html#setting-up
  + http://docs.aws.amazon.com/AWSAndroidSDK/latest/javadoc/
  + http://docs.aws.amazon.com/mobile/sdkforandroid/developerguide/s3transfermanager.html
- Posibilidad. ¿Conectar con flickr o similares en lugar de Amazon?

*** Hecho
- [17 junio] Añadir más recetas para empezar con la APP Android.

*** Ideas
- Añadir a "Opciones de configuración" la posibilidad de descargar en la DB
  todas las recetas que se vean.
- En la vista de detalle de "paso de preparación", ¿posibilidad de cambiar el
  tiempo del cronómetro?
- Sacar el GET de comentarios fuera del GET de Recipes (en la API), para evitar
  que se ralentice la app.
- ¿Sincronización con flickr o imgur?

* Fuentes
*** Plantillas
- Django REST skeleton (plantilla):
  https://github.com/sebastibe/django-rest-skeleton
- Django REST framework template:
  http://vincent.is/making-a-django-rest-framework-template/
*** Modelos
- Django Model Utils: https://django-model-utils.readthedocs.org/en/latest/index.html
-
  http://stackoverflow.com/questions/18958205/concurrent-requests-in-django
-
  http://stackoverflow.com/questions/1355150/django-when-saving-how-can-you-check-if-a-field-has-changed
*** Imgur
- http://api.imgur.com/
- https://github.com/jacobgreenleaf/imgur-python/
- https://github.com/talklittle/ImgurAPIv3ExampleAndroid
*** Postgres
- https://help.ubuntu.com/community/PostgreSQL
  
*** Material
- Especificación de Material Design: http://www.google.com/design/spec/material-design/introduction.html
- Material con Polymer: https://www.polymer-project.org/docs/elements/material.html#shadow-effect
