En este capítulo se detalla el diseño del proyecto, basado en el análisis
mostrado en anteriormente. Entre otros detalles, se presenta la arquitectura
general y el diseño físico de datos.

\section{Arquitectura del sistema}

\subsection{Arquitectura física}
\label{sec:arquitectura-fisica}

En este apartado, describimos los principales componentes hardware que forman
la arquitectura física de nuestro sistema, recogiendo por un lado los componentes
del servidor de producción y, por otro lado, los componentes del cliente de acceso.

\subsubsection{Servidor de producción}
\label{subsec:entorno-produccion}

\paragraph{Hardware}

El \textit{hardware} mínimo indispensable para la correcta ejecución de la API
es el siguiente:

\begin{itemize}
\item 512MiB de memoria RAM.
\item 10GiB de disco duro.
\item Acceso a Internet con un canal de subida de al menos 1Mbit/s.
\end{itemize}


\paragraph{Software}

En cuanto al \textit{software} necesario para la ejecución del proyecto, se
detallan los siguientes elementos, que es necesario instalar para desplegar el
sistema:

\begin{itemize}
\item Sistema operativo \textbf{GNU/Linux}. Durante el desarrollo del proyecto y
  en el actual servidor de producción se utilizó Ubuntu.
\item Código fuente del proyecto \textbf{Amuse Bouche}.
\item Servidor de shell remota \textbf{SSH}, accesible desde el exterior.
\item \textbf{Nginx} como servidor web.
\item \textbf{Supervisord} como sistema para el control de procesos que trabajen
  en modo demonio.
\item \textbf{Python}, versión mínima 3.0.
\item Soporte de entornos virtuales \textbf{VirtualEnv} para la encapsulación de
  dependencias.
\end{itemize}

\subsubsection{Cliente de la aplicación Android}

Los usuarios que deseen utilizar la app deberán contar con un dispositivo que
soporte como mínimo la versión 4.0 del sistema operativo Android. Para la
instalación inicial se necesitará que posean acceso a internet y a los servicios
de Google Play. Posteriormente podrán utilizar la app sin conectarse, si así lo
desean.


\subsection{Arquitectura lógica}

La arquitectura lógica del sistema está formada por los elementos software
(servicios, aplicaciones, librerías, \textit{frameworks}, etc.) que componen el
software base, más el software desarrollado para cumplir los requisitos de la
aplicación. En esta sección se especficia la organización de los distintos
elementos software que componen el proyecto así como la comunicación entre
ellos. 

\subsubsection{Arquitectura de la API}
\label{subsec:arquitectura-logica-api}

En la figura~\ref{fig:arquitectura-logica-api} se puede ver un esquema de cómo se
comunican los diferentes elementos que conforma el sistema web a alto nivel. En
detalle, el flujo que sigue en cada capa es el siguiente.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{cap5/img/diagrama_arquitectura_logica_api}
  \caption{Arquitectura lógica de la API}
  \label{fig:arquitectura-logica-api}
\end{figure}



\paragraph{Cliente}

Cuando usuario desea realizar una acción en la aplicación, esto se traduce como
enviar una petición \ac{HTTP} al servidor, es decir, se abre una conexión
\ac{TCP} al puerto 80 del servidor remoto y enviar las cabeceras en las cuales
debe indicarse qué datos se desean obtener o accción se desea llevar a cabo.

\paragraph{Servidor web}

Para que el servidor pueda escuchar dichas peticiones y responder a ellas, debe
tener en ejecución algún servicio que pueda hacerlo. Como ya hemos adelantado,
en el caso en que nos encontramos, se utiliza \textit{nginx}, un servidor web
que recibirá las peticiones HTTP hechas externamente.

Al tratarse de la obtención de una serie de recursos dinámicos (páginas generadas
dinámicamente, como es el caso) \textit{nginx} actuará como un proxy inverso y trasladará
la petición al manejador que corresponda.

\paragraph{Servidor de aplicaciones}

El manejador correspondiente en este proyecto es el servidor \textit{Gunicorn},
el cual está basado en el modelo \textit{pre-form worker}. Gunicorn instancia
varios procesos al lanzar el servidor que se encargarán de procesar las
peticiones de forma paralela, según el proceso padre las reparta.

En Python existe un estándar en el desarrollo web, conocido como \ac{WSGI}, una
especificación de una interfaz universal y simple entre los servidores web y
las aplicaciones web. Es decir, según este estándar se regula la forma en que
se comunica la aplicación con el servidor web. Entonces, cuando un proceso
recibe una petición se comunica con la interfaz WSGI de la aplicación que vaya
a ejecutar, traslandándole la petición y esperando que le informe cuando la
repsuesta esté lista.

\paragraph{Punto de entrada WSGI}

Como se ha comentado, el proceso del servidor de aplicaciones se comunica con la
interfaz WSGI. Todas las aplicaciones desarrolladas en Django cuentan con un
módulo \texttt{wsgi.py} que actúa como punto de entrada WSGI y que directamente
pasa la petición al \textit{middleware} del framework, que empieza el
procesamiento.

\paragraph{Framework web}

El framework escogido, como ya quedó especificado en la
sección~\ref{sec:alternativas-solucion}, es \textbf{Django}~\cite{django:mvc}. El
objetivo fundamental de este \textit{framework} es facilitar la creación de
sitios web complejos, haciendo especial hincapié en un ritmo de desarrollo
rápido y evitar la duplicidad de código. Por lo que el mayor potencial de Django
es la gran cantidad de funcionalidad que ya trae integrada, ya sea en el propio
núcleo del \textit{framework} o a través de módulos oficiales que se incluyen en
la distribución oficial.


\paragraph{Middleware Django y aplicación}

A partir de este punto, la petición va desplazándose entre código propio del
\textit{framework} Django y el código de la aplicación. El flujo habitual, en su
forma más básica es el siguiente:

\begin{enumerate}
\item Los módulos de \textit{middleware} que gestionan las peticiones reciben la
  petición actual.
\item Django revisa el fichero \texttt{urls.py} de la aplicación, que contiene
  una lista de URLs asociadas a funciones. Django compara la URL de la petición
  recibida y mira si coincide con alguna de las URLs del proyecto.
\item Si no hay coincidencia, Django devuelve una respuesta negativa,
  normalmente en forma de código de estado 404.
\item Si hay coincidencia, Django llama a la función asociada a esa URL, que
  procesa la petición, devolviendo una respuesta.
\item Esa respuesta hace el camino de forma inversa hasta volver al cliente.
\end{enumerate}

Cada aplicación en Django cuenta con una arquitectura de tres capas conocida
como \textbf{Modelo-Plantilla-Vista}, que es parejo al patrón del
\textbf{Modelo-Vista-Controlador}~\cite{django:mvc}.

\begin{itemize}
\item El \textbf{modelo} representa la información en la base de datos, evitando
  al usuario tener que utilizar código SQL. Para ello, Django cuenta con un
  \ac{ORM} que facilita el trabajo con registros de la base de datos.
\item Las \textbf{vistas} suelen ser funciones asociadas a una URL. La filosofía
  de Django es que las vistas sirvan solo como \textit{punto de paso} de los
  datos entre los modelos y las plantillas. Es mala práctica colocar lógica de
  negocio compleja en las vistas.
\item Las \textbf{plantillas} son la representación final de los datos, lo que
  acaba viendo el usuario. Las plantillas suelen estar escritas en HTML aunque
  pueden también representarse usando JSON, XML, etc.
\end{itemize}

La estructura de ficheros de un proyecto Django se ajusta, por tanto, a la
organización lógica hasta ahora descrita. Así, la raíz del proyecto contiene:
\begin{itemize}
\item \texttt{amuseapi} Directorio de proyecto a nivel global (para el caso en
  que existieran varias aplicaciones en un mismo proyecto)..
  \begin{itemize}
  \item \texttt{settings.py} Configuración general.
  \item \texttt{urls.py} Configuración de URLs.
  \item \texttt{wsgi.py} Punto de acceso WSGI.
  \end{itemize}
\item \texttt{recipes} Directorio de la aplicación de recetas.
  \begin{itemize}
  \item \texttt{models.py} Definición de modelos.
  \item \texttt{permissions.py} Definición de permisos.
  \item \texttt{serializers.py} Definición de serializadores (intermediarios
    entre las vistas y los modelos).
  \item \texttt{views.py} Definición de vistas (funciones).
  \item \texttt{tests.py} Definición de tests.
  \end{itemize}
\end{itemize}



\subsubsection{Aplicación Android}
\label{subsec:arquitectura-logica-android}

Android está construido con una arquitectura de 4 capas relacionadas entre
sí.~\cite{learning-android}. En la figura~\ref{fig:arquitectura-logica-app} se
puede ver que la estructura de Android se encuentra construida sobre el
\textit{kernel} de Linux. Luego hay una capa de bibliotecas relacionadas con una
estructura administradora en tiempo de ejecución. En el siguiente nivel
encontramos un \textit{framework} de apoyo para construcción de aplicaciones y,
por último, tenemos la capa de las aplicaciones.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{cap5/img/diagrama_arquitectura_logica_app}
  \caption{Arquitectura lógica de la app}
  \label{fig:arquitectura-logica-app}
\end{figure}


\paragraph{Kernel de Linux}

Android está construido sobre el núcleo de Linux, modificado para adaptarse a
dispositivos móviles. Esta elección está basada en la excelente flexibilidad y
seguridad que Linux presenta. Ya que el \textit{kernel} de Linux se encuentra
licenciado bajo \ac{GPL}, Android también lo está.



\paragraph{Bibliotecas}

Entre las bibliotecas que forman parte de esta capa se encuentran las
siguientes:
\begin{description}
\item[Capa de abstracción del hardware] Permite la independencia del hardware,
  es decir, añade la capacidad de poder ejecutar el sistema en cualquier
  dispositivo móvil sin importar su arquitectura física. Este sistema actúa
  como una arquitectura genérica que representa todos los posibles tipos de
  hardware existentes en el mercado. Aunque por el momento no hay estándares de
  construcción en el hardware de dispositivos móviles, la capa de abstracción
  permite que cada fabricante ajuste sus preferencias para que Android pueda
  funcionar sobre ella.
  
\item[Bibliotecas nativas] Son las interfaces de código abierto para múltiples
  usos, como OpenGL para el renderizado de gráficos 3D, SQLite para la gestión
  de bases de datos, WebKit para el renderizado en navegadores, ... También
  existen bibliotecas para soportar los servicios del sistema como el Wifi,
  el GPS y la telefonía, entre otros.
  
\item[Demonios] Son programas que están en segundo plano ejecutándose, esperando
  algún tipo de llamada o evento para ser lanzados.

\item[Máquina virtual] Las aplicaciones Android están escritas en lenguaje Java
  y son traducidas a \textit{bytecode}, como las aplicaciones Java tradicionales.
  Sin embargo, éstas no son interpretadas por la máquina virtual de Java tal y
  como lo hacían las otras. Android tiene su propia máquina virtual.

  Era necesario construir una máquina virtual específica por varios motivos:
  el primero y más esencial es que la \ac{JVM} no tiene licencia GPL, y la
  segunda es que se necesitaba que fuera flexible ante el diseño de hardware de
  un dispositivo móvil. Así, Google creó su propia máquina virtual.

  Desde la versión 2.2 de Android, se utilizaba para este fin la máquina virtual
  Davil. Sin embargo, con la llegada de Android 4.4, ART debutó como entorno de
  ejecución alternativo y reemplazó completamente a Dalvik a partir de Android
  5.0 Lollipop. \ac{ART}~\cite{art-and-dalvik} es un entorno de ejecución de
  aplicaciones que lleva a cabo la transformación de la aplicación en
  instrucciones de máquina, que luego son ejecutadas por el entorno de ejecución
  nativo del dispositivo.  

  La construcción de una aplicación Java empieza por traducir el código fuente
  con el compilador de Java, javac, para obtener el código \textit{bytecode}
  contenido en archivos \textit{.class}. Al final, la JVM interpreta en tiempo
  real estos archivo y la aplicación es ejecutada.

  Cuando se usaba Dalvik, la construcción de una aplicación Android se basaba en
  que el compilador de Java tradujera la aplicación a \textit{bytecode}, y
  entonces el compilador Dex compilara este código a \textit{bytecode} nativo que
  será convertido en un ejecutable \textit{.dex}. Finalmente este archivo es
  ejecutado por una instancia de Dalvik VM.
  
  Para mantener la compatibilidad con versiones anteriores, ART utiliza el mismo
  \textit{bytecode} de entrada que Dalvik, el cual es suministrado a través de
  archivos \textit{.dex} estándar como parte de los archivos \ac{APK}, mientras
  que los archivos \textit{.odex} son reemplazados por archivos de formato
  ejecutable y enlazable (ELF). Una vez que una aplicación se compila utilizando
  ART en el dispositivo, ésta es dirigida exclusivamente a partir del ejecutable
  ELF compilado. Este enfoque elimina diversos gastos involucrados con la
  compilación JIT, pero requiere de tiempo adicional para la compilación cuando
  se instala la aplicación. También las aplicaciones ocupan cantidades
  ligeramente mayores de espacio de almacenamiento para almacenar el
  \textit{bytecode} compilado.

  Toda la arquitectura comentada está esquematizada en la
  figura~\ref{fig:arquitectura-art}.   

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{cap5/img/ART}
  \caption{Diagrama de la arquitectura de Android Run Time}
  \label{fig:arquitectura-art}
\end{figure}
\end{description}


\paragraph{Framework para aplicaciones}

En esta capa todas las bibliotecas Java que se necesitan para programar las
aplicaciones. Los paquetes más utilizados son los empaquetados en
\texttt{android.*}, ya que en ellos se encuentran todas las características
necesarias para construir una aplicación Android, aunque también es posible
acceder a clases como \texttt{java.utils.*}, \texttt{java.net.*}, ... (salvo
aquellas bibliotecas excluidas, como \texttt{java.awt.*} y
\texttt{java.swing.*}).

En esta capa también encontraremos manejadores, servicios y proveedores de
contenido que soportan la comunicación de nuestra aplicación con el ecosistema
de Android.


\paragraph{Aplicaciones}

Es la última instancia de funcionamiento de Android. A este nivel acceden todos
los usuarios Android debido a su alto nivel de compresión y simplicidad.

El resultado del proceso de construcción de una app es un archivo comprimido con
formato APK (Android Applicacion Package\footnote{Un archivo APK es básicamente
  un archivo ZIP con una extensión diferente}), con la siguiente estructura:

\begin{itemize}
\item \texttt{META-INF}:
  \begin{itemize}
  \item \texttt{MANIFEST.MF}: El archivo Manifest.
  \item \texttt{CERT.RSA}: El certificado de la app.
  \item \texttt{CERT.SF}: La lista de recursos y recopilcación de SHA-1
    correspondientes al manifest.
  \end{itemize}
\item \texttt{lib}: Directorio que contiene el código compilado que es
  específico de una capa de software de un procesador.
  \begin{itemize}
  \item \texttt{armeabi}: Código compilador para procesadores basados en ARM
  \item \texttt{armeabi-v7a}: Código compilador para procesadores basados en
    ARMv7 o superior.
  \item \texttt{x86}: Código compilado para procesadores x86.
  \item \texttt{mips}: Código compilado para procesadores MIPS.
  \end{itemize}
\item \texttt{res}: Directorio que contiene los recursos no compilados en
  \texttt{resources.arsc}.
\item \texttt{assets}: Directorio que contiene los assets de la app, que pueden
  obtenerse mediante el \textit{AssetManager}.
\item \texttt{AndroidManifest.xml}: Un archivo manifest adicional, que describe
  el nombre, la versión, los derechos de acceso, archivos de biblioteca que se
  hace referencia para la aplicación.
\item \texttt{classes.dex}: Las clases compiladas en formato \textit{dex}.
\item \texttt{resources.ars}: Archivo que contiene recursos precompilados.
\end{itemize}

Este archivo APK se genera utilizando una herramienta de automatización: Gradle.
Se encarga de compilar, empaquetar, testear y liberar aplicaciones.


Una de las mayores ventajas de usar Gradle es que permite al desarrollador
modificar el flujo de construcción. Esto quiero decir que se puede decidir el
orden de ejecución de tareas. Asimismo podríamos elegir que archivos compilar
primero, cuando detener la compilación o establecer condiciones para que se
recompile o no el código.

Además Gradle permite ejecuciones incrementales, por lo que ahorra al
programador gran cantidad de tiempo de espera. También permite que construyamos
varias versiones de nuestra aplicación (para varias versiones de Android).

Otro detalle muy interesante es que se pueden ejecutar tareas en hilos
diferentes para optimizar el proceso de construcción.


\section{Diseño detallado de componentes}

En esta sección se detalla el diseño de algunas de las funcionalidades de la
aplicación, especificando las entidades que intervienen y el flujo de mensajes
que tiene lugar entre estas.

\subsection{Vista de usuario}

En la vista de usuario tiene lugar una serie de acciones que involucran tanto
a la API como a la base de datos de la aplicación, por lo que resulta interesante
de analizar. Todo el flujo explicado a continuación puede verse en la
figura~\ref{fig:diagrama-secuencia-login}.

Desde la vista inicial (generada mediante la \textit{Actividad principal}, el
usuario entra en la vista de usuario (de la cual es responsable la
\textit{Actividad de usuario}). Al entrar, se llama al método \textit{onCreate}
de la actividad en el cual se intenta obtener el \textit{token} de autenticación
del usuario de la base de datos. Si este no existiera o si fuera obsoleto, al
llamar a la petición de obtener datos de usuario, nos informaría de que el
\textit{token} es inválido. Como resultado, se mostraría la vista de login. Si
el \textit{token} fuera el correcto, se mostraría la vista de usuario en
sesión, que informa de que está correctamente logueado.

Si el usuario no ha podido iniciar sesión, puede optar por iniciarla o registrar
un nuevo usuario. Para iniciar sesión, introduciría los datos necesarios
(nombre de usuario y contraseña). La actividad lanzaría una petición a la API
que devolverá el \textit{token} que será guardado en la base de datos para
posteriores usos.

Para registrarse, el usuario debe introducir los datos necesarios (nombre de
usuario, contraseña, nombre, apellido y correo electrónico) y se lanzará la
correspondiente petición a la API que devolverá los datos del usuario
correctamente registrado.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{cap5/img/diagrama_secuencia_login}
  \caption{Diagrama de secuencia - Vista de usuario}
  \label{fig:diagrama-secuencia-login}
\end{figure}


\subsection{Creación de recetas}

En la vista de creación de recetas hay una particularidad interesante que
se analiza a continuación.

Desde la vista inicial (generada mediante la \textit{Actividad principal}, el
usuario entra en la vista de creación (de la cual es responsable la
\textit{Actividad de creación}) pulsando sobre el botón de añadir. Al entrar, se
llama al método \textit{onCreate} de la actividad, en el cual se crea una nueva
receta con valores por defecto. Una vez creada, se muestra la vista de creación
al usuario.

El usuario podrá ir modificando cada atributo en función de sus necesidades.
Cada vez que se modifique uno, se validará que su valor es correcto y se
informará al usuario. También se comprobará si todas las validaciones son
correctas para activar o desactivar el botón de guardado en función de esto.

Un caso particular sería al añadir un nuevo ingrediente a la receta. En este
caso, el usuario pulsará sobre el botón de añadir un nuevo ingrediente. Se
mostrará el diálogo pertinente, que requiere que se añadan el nombre, la cantidad
y la unidad de medida. Se validará cada atributo al igual que en el caso general:
el usuario podrá guardar el nuevo ingrediente cuando todos los valores sean
correctos. Cuando el usuario quiera guardar el ingrediente, este se añadirá a
la receta y se mostrará la actualización en la vista, pero además se hace una
llamada a la base de datos para buscar las categorías con las que está relacionado
dicho ingrediente. Se actualizan las categorías de la receta con las que se han
obtenido y se muestran en la vista.

Por último, cuando el usuario esté satisfecho con los datos que ha introducido y
todos sean válidos, podrá guardar la receta. La receta se creará en la base
de datos y se informará al usuario mediante un mensaje.

Todo este flujo puede verse en la figura~\ref{fig:diagrama-secuencia-crear-receta}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{cap5/img/diagrama_secuencia_crear_receta}
  \caption{Diagrama de secuencia - Creación de receta}
  \label{fig:diagrama-secuencia-crear-receta}
\end{figure}


\section{Diseño físico de datos}
\label{sec:diseno-fisico-datos}

\subsection{API}

En las figuras~\ref{fig:diagrama-fisico-datos-1},
\ref{fig:diagrama-fisico-datos-2} y \ref{fig:diagrama-fisico-datos-3} se
muestran los diagrama de modelos que se reflejará en la base de datos de la API,
donde se puede apreciar cada una de las tablas con sus campos y las relaciones
entre ellas.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{cap5/img/diagrama_fisico_datos_1}
  \caption{Diagrama físico de datos de la API I}
  \label{fig:diagrama-fisico-datos-1}
\end{figure}


A continuación se detalla todo lo especificado en dichos diagramas.

\subsubsection{AbstractUser}

Este modelo representa a un usuario registrado en el sistema. Forma parte de la
aplicación \texttt{django.contrib.auth}. El modelo \texttt{User} hereda de este.

Sus atributos son:
\begin{itemize}
\item \texttt{username}: De tipo cadena. Representa el nombre de usuario.
\item \texttt{email}: De tipo cadena. Representa la dirección de correo
  electrónico.
\item \texttt{first\_name}: De tipo cadena. Representa el nombre.
\item \texttt{last\_name}: De tipo cadena. Representa el apellido.
\item \texttt{is\_active}: De tipo booleano. Especifica si el usuario está
  activado.
\item \texttt{is\_staff}: De tipo booleano. Especifica si el usuario forma parte
  del staff.
\item \texttt{is\_superuser}: De tipo booleano. Especifica si el usuario es
  superusuario.
\item \texttt{last\_login}: De tipo fecha. Representa la última fecha de acceso
  al sistema.
\item \texttt{password}: De tipo cadena. Representa la contraseña del usuario.
  Se almacena cifrada irreversiblemente de acuerdo a las exigencias de la actual
  Ley de Protección de Datos.
\end{itemize}


\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{cap5/img/diagrama_fisico_datos_2}
  \caption{Diagrama físico de datos de la API II}
  \label{fig:diagrama-fisico-datos-2}
\end{figure}

\subsubsection{User}

Este modelo hereda todos sus atributos y métodos de \texttt{AbstractUser}. Se
utiliza para modificar los campos requeridos de \texttt{AbstractUser} y para
generar el \textit{token} de autenticación.

Sus relaciones son:
\begin{itemize}
\item User - Recipe: 1:*
\item User - Token: 1:1 
\end{itemize}

\subsubsection{Session}

Este modelo representa una sesión de un usuario que ha accedido mediante web.
Forma parte de la aplicación \texttt{django.contrib.sessions}.

Sus atributos son:
\begin{itemize}
\item \texttt{session\_key}: De tipo cadena. Representa el identificador de la
  sesión.
\item \texttt{session\_data}: De tipo texto. Representa los datos asociados a la
  sesión.
\item \texttt{expire\_date}: De tipo fecha. Representa hasta qué fecha son
  válidos los datos de la sesión.
\end{itemize}

\subsubsection{Token}

Este modelo representa un \textit{token} de autenticación asignado a un usuario.
Forma parte de la aplicación \texttt{rest-framework.authtoken}.

Sus atributos son:
\begin{itemize}
\item \texttt{key}: De tipo cadena. Representa la clave del \textit{token}.
\item \texttt{user}: Clave foránea. Representa el usuario al cual se le ha
  asignado este \textit{token}.
\item \texttt{created}: De tipo fecha. Representa el momento de creación.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item User - Token: 1:1 
\end{itemize}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{cap5/img/diagrama_fisico_datos_3}
  \caption{Diagrama físico de datos de la API III}
  \label{fig:diagrama-fisico-datos-3}
\end{figure}


\subsubsection{Recipe}

Este modelo representa una receta descrita por un usuario.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único de la
  receta.
\item \texttt{owner}: Clave foránea. Representa el usuario creador de la receta.
\item \texttt{language}: De tipo enumerado. Representa el idioma en el cual está
  escrita la receta. Puede tomar los siguientes valores:
  \begin{itemize}
  \item es
  \item en
  \end{itemize}
\item \texttt{type\_of\_dish}: De tipo enumerado. Representa el tipo de plato.
  Puede tomar los siguientes valores:
  \begin{itemize}
  \item LOW
  \item MEDIUM
  \item HIGH
  \end{itemize}
\item \texttt{difficulty}: De tipo enumerador. Representa la dificultad de
  realización de la receta. Puede tomar los siguientes valores:
  \begin{itemize}
  \item APPETIZER
  \item FIRST-COURSE
  \item SECOND-COURSE
  \item MAIN-DISH
  \item DESSERT
  \item OTHER
  \end{itemize}
\item \texttt{created\_timestamp}: De tipo fecha. Representa el momento de
  creación de la receta.
\item \texttt{updated\_timestamp}: De tipo fecha. Representa el momento de
  última actualización de la receta.
\item \texttt{cooking\_time}: De tipo flotante. Representa el tiempo que tarda
  en ejecutarse la receta.
\item \texttt{image}: De tipo URL. Representa la URL de la imagen asociada a la
  receta.
\item \texttt{total\_rating}: De tipo entero. Representa el sumatorio total de
  todas las valoraciones de la receta.
\item \texttt{users\_rating}: De tipo entero. Representa la cantidad total de
  usuarios que han valorado la receta.
\item \texttt{average\_rating}: De tipo flotante. Representa la media de
  valoraciones de la receta.
\item \texttt{servings}: De tipo entero. Representa el número de comensales que
  pueden comer preparando la receta.
\item \texttt{source}: De tipo cadena. Representa la fuente original de la
  receta.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item User - Recipe: 1:*
\item Recipe - RecipeCategory: 1:*
\item Recipe - RecipeIngredient: 1:*
\item Recipe - RecipeDirection: 1:*
\item Recipe - RecipeComment: 1:*
\item Recipe - RecipeRating: 1:*
\end{itemize}


\subsubsection{RecipeCategory}

Este modelo representa una categoría asociada a una receta.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único de la
  categoría.
\item \texttt{recipe}: Clave foránea. Representa la receta a la que pertenece
  esta categoría.
\item \texttt{name}: De tipo enumerado. Representa el nombre de la categoría.
  Puede tomar los siguientes valores:
  \begin{itemize}
  \item GLUTEN\_ALLERGY
  \item LACTOSE\_ALLERGY
  \item FISH\_ALLERGY
  \item SHELLFISH\_ALLERGY
  \item DRIED\_FRUIT\_ALLERGY
  \item VEGETARIAN
  \item VEGAN
  \item MEDITERRANEAN
  \item UNCATEGORIZED
  \end{itemize}
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeCategory: 1:*
\end{itemize}


\subsubsection{RecipeIngredient}

Este modelo representa un ingrediente asociado a una receta.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único del
  ingrediente.
\item \texttt{recipe}: Clave foránea. Representa la receta a la que pertenece
  este ingrediente.
\item \texttt{sort\_number}: De tipo entero. Representa la posición del
  ingrediente dentro del listado completo asociado a la receta.
\item \texttt{name}: De tipo cadena. Representa el nombre del ingrediente.
\item \texttt{quantity}: De tipo flotante. Representa la cantidad del
  ingrediente.
\item \texttt{measurement\_unit}: De tipo enumerado. Representa la unidad de
  medida en que se mida la cantidad del ingrediente. Puede tomar los siguientes
  valores:
  \begin{itemize}
  \item g
  \item kg
  \item ml
  \item l
  \item pound
  \item oz
  \item glass
  \item unit
  \item cup
  \item tbsp
  \item tsp
  \item rasher
  \item stalk
  \end{itemize}
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeIngredient: 1:*
\end{itemize}


\subsubsection{RecipeDirection}

Este modelo representa un paso asociado a una receta.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único del
  paso.
\item \texttt{recipe}: Clave foránea. Representa la receta a la que pertenece
  este paso.
\item \texttt{sort\_number}: De tipo entero. Representa la posición del
  paso dentro del listado completo asociado a la receta.
\item \texttt{description}: De tipo cadena. Representa la descripción del paso
  a realizar.
\item \texttt{image}: De tipo URL. Representa la URL de la imagen asociada a
  este paso.
\item \texttt{video}: De tipo URL. Representa la URL del video asociado a este
  paso.
\item \texttt{time}: De tipo flotante. Representa el tiempo de cronómetro que
  puede activarse tras la ejecución del paso.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeDirection: 1:*
\end{itemize}


\subsubsection{RecipeComment}

Este modelo representa un comentario asociado a una receta.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único del
  ingrediente.
\item \texttt{recipe}: Clave foránea. Representa la receta a la que pertenece
  este ingrediente.
\item \texttt{comment}: De tipo cadena. Representa el comentario.
\item \texttt{timestamp}: De tipo fecha. Representa el momento de creación del
  comentario.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeComment: 1:*
\end{itemize}


\subsubsection{RecipeRating}

Este modelo representa una valoración asociada a una receta.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único de la
  valoración.
\item \texttt{recipe}: Clave foránea. Representa la receta a la que pertenece
  esta valoración.
\item \texttt{rating}: De tipo entero. Representa la puntuación.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeRating: 1:*
\end{itemize}



\subsubsection{Ingredient}

Este modelo representa un ingrediente categorizado de la aplicación.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único del
  ingrediente.
\item \texttt{code}: De tipo cadena. Representa el código identificativo del
  ingrediente.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Ingredient - TranslatedIngredient: 1:*
\item Ingredient - IngredientCategory: 1:*
\end{itemize}


\subsubsection{TranslatedIngredient}

Este modelo representa una traducción de un ingrediente.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único de la
  traducción.
\item \texttt{ingredient}: Clave foránea. Representa el ingrediente al que
  pertenece esta traducción.
\item \texttt{translation}: De tipo cadena. Representa la traducción del
  ingrediente.
\item \texttt{language}: De tipo enumerado. Representa el idioma en el cual está
  traducido el ingrediente. Puede tomar los siguientes valores:
  \begin{itemize}
  \item es
  \item en
  \end{itemize}
\item \texttt{timestamp}: De tipo fecha. Representa el momento de creación de la
  traducción.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Ingredient - TranslatedIngredient: 1:*
\end{itemize}


\subsubsection{IngredientCategory}

Este modelo representa una categoría asociada a un ingrediente.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único de la
  categoría.
\item \texttt{ingredient}: Clave foránea. Representa el ingrediente al que
  pertenece esta categoría.
\item \texttt{name}: De tipo enumerado. Representa el nombre de la categoría.
  Puede tomar los siguientes valores:
  \begin{itemize}
  \item GLUTEN\_ALLERGY
  \item LACTOSE\_ALLERGY
  \item FISH\_ALLERGY
  \item SHELLFISH\_ALLERGY
  \item DRIED\_FRUIT\_ALLERGY
  \item VEGETARIAN
  \item VEGAN
  \item MEDITERRANEAN
  \item UNCATEGORIZED
  \end{itemize}
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Ingredient - IngredientCategory: 1:*
\end{itemize}



\subsection{Aplicación móvil}

En la figura~\ref{fig:diagrama-fisico-datos-4} se encuentra el diagrama de
modelos de la base de datos de la aplicación móvil.


\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{cap5/img/diagrama_fisico_datos_4}
  \caption{Diagrama físico de datos de la aplicación móvil}
  \label{fig:diagrama-fisico-datos-4}
\end{figure}

A continuación se detalla todo lo especificado en dicho diagrama.


\subsubsection{AppData}

Este modelo representa las configuración y los datos de la aplicación guardados
como pares de clave-valor.

Sus atributos son:
\begin{itemize}
\item \texttt{key}: Clave primaria. Representa el identificador único del
  ingrediente que también refleja su significado asociado.
\item \texttt{value}: De tipo cadena. Representa el valor guardado para la
  clave dada.
\end{itemize}


\subsubsection{Ingredient}

Este modelo representa un ingrediente categorizado de la aplicación.

Sus atributos son:
\begin{itemize}
\item \texttt{\_id}: Clave primaria. Representa el identificador único del
  ingrediente.
\item \texttt{translation}: De tipo cadena. Representa la traducción del
  ingrediente.
\item \texttt{language}: De tipo enumerado. Representa el idioma en el cual está
  traducido el ingrediente.
\item \texttt{timestamp}: De tipo fecha. Representa el momento de creación de la
  traducción.
\item \texttt{categories}: De tipo cadena. Representa una cadena con todas las
  categorías asociadas al ingrediente separadas por un caracter especial.  
\end{itemize}


\subsubsection{Recipe}

Este modelo representa una receta descrita por un usuario.

Sus atributos son:
\begin{itemize}
\item \texttt{\_id}: Clave primaria. Representa el identificador único de la
  receta en la base de datos.
\item \texttt{id}: De tipo cadena. Representa el identificador único de la
  receta en la API.
\item \texttt{owner}: De tipo cadena. Representa el nombre de usuario del
  usuario creador de la receta.
\item \texttt{language}: De tipo enumerado. Representa el idioma en el cual está
  escrita la receta.
\item \texttt{type\_of\_dish}: De tipo enumerado. Representa el tipo de plato.
\item \texttt{difficulty}: De tipo enumerador. Representa la dificultad de
  realización de la receta.
\item \texttt{created\_timestamp}: De tipo fecha. Representa el momento de
  creación de la receta.
\item \texttt{updated\_timestamp}: De tipo fecha. Representa el momento de
  última actualización de la receta.
\item \texttt{cooking\_time}: De tipo flotante. Representa el tiempo que tarda
  en ejecutarse la receta.
\item \texttt{image}: De tipo cadena. Representa la URL de la imagen asociada a
  la receta.
\item \texttt{total\_rating}: De tipo entero. Representa el sumatorio total de
  todas las valoraciones de la receta.
\item \texttt{users\_rating}: De tipo entero. Representa la cantidad total de
  usuarios que han valorado la receta.
\item \texttt{average\_rating}: De tipo flotante. Representa la media de
  valoraciones de la receta.
\item \texttt{servings}: De tipo entero. Representa el número de comensales que
  pueden comer preparando la receta.
\item \texttt{source}: De tipo cadena. Representa la fuente original de la
  receta.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeCategory: 1:*
\item Recipe - RecipeIngredient: 1:*
\item Recipe - RecipeDirection: 1:*
\end{itemize}


\subsubsection{RecipeCategory}

Este modelo representa una categoría asociada a una receta.

Sus atributos son:
\begin{itemize}
\item \texttt{\_id}: Clave primaria. Representa el identificador único de la
  categoría.
\item \texttt{\_recipe\_id}: Representa el identificador de la base de datos de
  la receta a la que pertenece esta categoría
\item \texttt{recipe\_id}: Representa el identificador de la API de la receta
  a la que pertenece esta categoría.
\item \texttt{name}: De tipo enumerado. Representa el nombre de la categoría.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeCategory: 1:*
\end{itemize}


\subsubsection{RecipeIngredient}

Este modelo representa un ingrediente asociado a una receta.

Sus atributos son:
\begin{itemize}
\item \texttt{id}: Clave primaria. Representa el identificador único del
  ingrediente.
\item \texttt{\_recipe\_id}: Representa el identificador de la base de datos de
  la receta a la que pertenece este ingrediente.
\item \texttt{recipe\_id}: Representa el identificador de la API de la receta
  a la que pertenece este ingrediente.
\item \texttt{sort\_number}: De tipo entero. Representa la posición del
  ingrediente dentro del listado completo asociado a la receta.
\item \texttt{name}: De tipo cadena. Representa el nombre del ingrediente.
\item \texttt{quantity}: De tipo flotante. Representa la cantidad del
  ingrediente.
\item \texttt{measurement\_unit}: De tipo cadena. Representa la unidad de
  medida en que se mida la cantidad del ingrediente.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeIngredient: 1:*
\end{itemize}


\subsubsection{RecipeDirection}

Este modelo representa un paso asociado a una receta.

Sus atributos son:
\begin{itemize}
\item \texttt{\_id}: Clave primaria. Representa el identificador único del
  paso.
\item \texttt{\_recipe\_id}: Representa el identificador de la base de datos de
  la receta a la que pertenece este paso.
\item \texttt{recipe\_id}: Representa el identificador de la API de la receta
  a la que pertenece este paso.
\item \texttt{sort\_number}: De tipo entero. Representa la posición del
  paso dentro del listado completo asociado a la receta.
\item \texttt{description}: De tipo cadena. Representa la descripción del paso
  a realizar.
\item \texttt{image}: De tipo cadena. Representa la URL de la imagen asociada a
  este paso.
\item \texttt{video}: De tipo cadena. Representa la URL del video asociado a este
  paso.
\item \texttt{time}: De tipo flotante. Representa el tiempo de cronómetro que
  puede activarse tras la ejecución del paso.
\end{itemize}

Sus relaciones son:
\begin{itemize}
\item Recipe - RecipeDirection: 1:*
\end{itemize}


\section{Diseño de la imagen corporativa}

La imagen corporativa del proyecto comprende el diseño del logotipo, la elección
de la paleta de colores y las tipografías, que se usan en el diseño de la app y
cualquier otro elemento visual.

El diseño completo se ha basado en
\textit{Material Design}.\cite{material-design} Este diseño recibe su nombre por
estar basado en objetos materiales: piezas colocadas en un espacio (lugar) y con
un tiempo (movimiento) determinado.

Es un diseño donde la profundidad, las superficies, los bordes, las sombras y
los colores juegan un papel principal.

Algunos detalles importantes a la hora de abordar el diseño son:
\begin{itemize}
\item Utilizar una tipografía clara, casillas bien ordenadas, colores e
  imágenes llamativos para no perder el foco y un sentido del orden y la
  jerarquía muy marcado.
\item También es necesario crear una iluminación realista que proporcione
  indicios de cómo se comportará un elemento y en qué nivel se encuentra.
\item Crear animaciones y movimientos, que indiquen el flujo a seguir.
\end{itemize}


\subsection{Nombre del proyecto}

El propio nombre del proyecto también forma parte de la imagen corporativa. Dada
la naturaleza del proyecto y lo que se buscaba conseguir, se trataba de buscar
un nombre atrayente relacionado con la comida, algo que llamara más la atención
que un simple \textit{``Tu recetario de cocina''}.

Investigando un poco, hay un concepto propio de la cocina
francesa,\cite{gastronomia-francia} denominado \textit{``amuse-bouche''}. No hay
nada más relacionado con la cocina que el francés, dado que la gastronomía
francesa es una de las más importantes del mundo, tanto culturalmente como por
sus materias primas y por su refinamiento. Tanto es así, que está incluida en la
lista del Patrimonio Cultural Inmaterial de la Humanidad.

Dicho esto, el propio concepto de \textit{``amuse-bouche''}, literalmente
traducido como \textit{``entretenimiento para la boca''},\cite{amuse-bouche}
hace referencia a los entremeses en la cocina. Se consideró como un término más
que apropiado para este proyecto.


\subsection{Diseño del logotipo}

Una vez decidido el nombre del proyecto, estaba claro que el logotipo debía
reflejar su nombre. Por tanto, había que inspirarse en los entremeses clásicos
para crear una nueva receta, la cual sería vectorizada y mostrada como un icono.

La receta creada consta de una base de pepino cuyos laterales han sido
recortados y se ha laminado. Justo encima se coloca una crema de queso y
con una pizca de cebollino. Y para rematar un gajo de tomate cherry.

Tomado desde una perspectiva vertical y conservando la iluminación, el logotipo
queda tal y como se ve en la figura~\ref{fig:logotipo}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.4\textwidth]{cap5/img/logotipo}
  \caption{Logotipo de Amuse Bouche}
  \label{fig:logotipo}
\end{figure}


\subsection{Elección de la gama cromática}

Una vez diseñado el logotipo, los colores principales sobre los que construir
la paleta de colores estaban ya presentes en este. Debían ser colores vibrantes
y atrevidos, basados en 2 tonos principales y opuestos.

Así, se decidió optar por la gama que se detalla en la
figura~\ref{fig:paleta-colores}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.3\textwidth]{cap5/img/paleta_colores}
  \caption{Paleta de colores de Amuse Bouche}
  \label{fig:paleta-colores}
\end{figure}


\subsection{Elección de la tipografía}

Siguiendo las directrices del diseño Material, optamos por la fuente Roboto,
por sus características y porque es la fuente por defecto en las nuevas versiones
de Android.

Roboto~\cite{roboto-font} tiene una naturaleza dual. Tiene un esqueleto mecánico y
las formas son en gran parte geométricas. Al mismo tiempo, la fuente cuenta con
curvas suaves y abiertas. Está publicada bajo licencia Apache. La fuente fue
completamente diseñada por el diseñador de interfaces de Google Christian
Robertson, que también diseñó la fuente Titling incluida en el sistema operativo
Ubuntu. 


\section{Diseño de la interfaz de usuario}

En esta sección se detallarán las interfaces visuales de la app del proyecto,
indicando qué acciones realizan cada uno de los componentes que las conforman.

TODO
